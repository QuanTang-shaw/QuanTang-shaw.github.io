<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
<!-- <script>

	function PubSub() {
	    this.handlers = {};
	}
	PubSub.prototype = {
	    // 订阅事件
	    on: function(eventType,handler){
	        var self = this;
	        if(!(eventType in self.handlers)) {
	             self.handlers[eventType] = [];
	        }
	        self.handlers[eventType].push(handler);
	        return this;
	       },
	       // 触发事件(发布事件)
	       emit: function(eventType){
	           var self = this;
	           var handlerArgs = Array.prototype.slice.call(arguments,1 );
	           for(var i = 0; i < self.handlers[eventType].length; i++) {
	                 self.handlers[eventType][i].apply(self,handlerArgs);
	           }
	           return self;
	       }
	};



		// 观察者构造函数
	function Observer(data) {
	    this.data = data;
	    this.walk(data);
	    this.event=new PubSub();
	}

	// let p = Observer.prototype;

	// 此函数用于深层次遍历对象的各个属性
	// 采用的是递归的思路
	// 因为我们要为对象的每一个属性绑定getter和setter
	Observer.prototype.walk = function (obj) {
	    let val;
	    for (let key in obj) {
	        // 这里为什么要用hasOwnProperty进行过滤呢？
	        // 因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来
	        // 而我们想要的仅仅是这个对象本身拥有的属性，所以要这么做。
	        if (obj.hasOwnProperty(key)) {
	            val = obj[key];

	            // 这里进行判断，如果还没有遍历到最底层，继续new Observer
	            if (typeof val === 'object') {
	                new Observer(val);
	            }

	            this.convert(key, val);
	        }
	    }
	};

	Observer.prototype.convert = function (key, val) {
		let self=this;
	    Object.defineProperty(this.data, key, {
	        enumerable: true,
	        configurable: true,
	        get: function () {
	            console.log('你访问了' + key);
	            return val
	        },
	        set: function (newVal) {
	            console.log('你设置了' + key);
	            console.log('新的' + key + ' = ' + newVal)
	            self.event.emit(key);
	            if (newVal === val) return;
	            val = newVal
	        }
	    })
	};

	Observer.prototype.$watch=function (attr,callback) {
		this.event.on(attr,callback);
	}	

	var app=new Observer({
		name: 'liujianhuan',
		age: 25,
		company: 'Qihoo 360',
		address: 'Chaoyang, Beijing'
	});
	app.$watch('age', function(oldVal, newVal){
	console.log(`我的年龄变了，原来是: ${oldVal}岁，现在是：${newVal}岁了`)
	});

	app.$watch('age', function(oldVal, newVal){
	console.log(`我的年龄真的变了诶，竟然年轻了${oldVal - newVal}岁`)
	});

	// app.data.basicInfo.age = 20;
</script> -->
<script src="02.js"></script>
</body>
</html>